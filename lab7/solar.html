<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script type="text/javascript">
        var gl;
        var shaderProgram;
        var uPMatrix;
        var vertexPositionBuffer;
        var vertexColorBuffer;
        var vertexCoordsBuffer;
        var vertexNormalBuffer;

        function MatrixMul(a, b) //Mnożenie macierzy
        {
            let c = [
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
            ]
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    c[i * 4 + j] = 0.0;
                    for (let k = 0; k < 4; k++) {
                        c[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return c;
        }

        function MatrixTransposeInverse(m) {
            let r = [
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
            ];
            r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15] + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10];
            r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15] - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10];
            r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15] + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6];
            r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11] - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6];

            r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15] - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10];
            r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15] + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10];
            r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15] - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6];
            r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11] + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6];

            r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15] + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9];
            r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15] - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9];
            r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15] + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5];
            r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11] - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5];

            r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14] - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9];
            r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14] + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9];
            r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14] - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5];
            r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10] + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5];

            var det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12];
            for (var i = 0; i < 16; i++) r[i] /= det;

            let rt = [r[0], r[4], r[8], r[12],
            r[1], r[5], r[9], r[13],
            r[2], r[6], r[10], r[14],
            r[3], r[7], r[11], r[15]
            ];

            return rt;
        }

        function CreateIdentytyMatrix() {
            return [
                1, 0, 0, 0, //Macierz jednostkowa
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }

        function CreateTranslationMatrix(tx, ty, tz) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                tx, ty, tz, 1
            ];
        }

        function CreateScaleMatrix(sx, sy, sz) {
            return [
                sx, 0, 0, 0,
                0, sy, 0, 0,
                0, 0, sz, 0,
                0, 0, 0, 1
            ];
        }

        function CreateRotationZMatrix(angleZ) {
            return [
                +Math.cos(angleZ * Math.PI / 180.0), +Math.sin(angleZ * Math.PI / 180.0), 0, 0,
                -Math.sin(angleZ * Math.PI / 180.0), +Math.cos(angleZ * Math.PI / 180.0), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }

        function CreateRotationYMatrix(angleY) {
            return [
                +Math.cos(angleY * Math.PI / 180.0), 0, -Math.sin(angleY * Math.PI / 180.0), 0,
                0, 1, 0, 0,
                +Math.sin(angleY * Math.PI / 180.0), 0, +Math.cos(angleY * Math.PI / 180.0), 0,
                0, 0, 0, 1
            ];
        }

        function CreateRotationXMatrix(angleX) {
            return [
                1, 0, 0, 0,
                0, +Math.cos(angleX * Math.PI / 180.0), +Math.sin(angleX * Math.PI / 180.0), 0,
                0, -Math.sin(angleX * Math.PI / 180.0), +Math.cos(angleX * Math.PI / 180.0), 0,
                0, 0, 0, 1
            ];
        }

        function createRect(mx, my, mz, dax, day, daz, dbx, dby, dbz) {
            p1x = mx; p1y = my; p1z = mz;
            p2x = mx + dax; p2y = my + day; p2z = mz + daz;
            p3x = mx + dbx; p3y = my + dby; p3z = mz + dbz;
            p4x = mx + dax + dbx; p4y = my + day + dby; p4z = mz + daz + dbz;

            let vertexPosition = [p1x, p1y, p1z, p2x, p2y, p2z, p4x, p4y, p4z,  //Pierwszy trójkąt
                p1x, p1y, p1z, p4x, p4y, p4z, p3x, p3y, p3z]; //Drugi trójkąt

            return vertexPosition;
        }

        function createRect2(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z) {
            let vertexPosition = [p1x, p1y, p1z, p2x, p2y, p2z, p4x, p4y, p4z,  //Pierwszy trójkąt
                p1x, p1y, p1z, p4x, p4y, p4z, p3x, p3y, p3z]; //Drugi trójkąt

            return vertexPosition;
        }


        function createRectCoords(mu, mv, dau, dav, dbu, dbv) {
            let p1u = mu; p1v = mv;
            let p2u = mu + dau; p2v = mv + dav;
            let p3u = mu + dbu; p3v = mv + dbv;
            let p4u = mu + dau + dbu; p4v = mv + dav + dbv;

            let vertexCoord = [p1u, p1v, p2u, p2v, p4u, p4v,  //Pierwszy trójkąt
                p1u, p1v, p4u, p4v, p3u, p3v]; //Drugi trójkąt

            return vertexCoord;
        }
        function createRectCoords2(p1u, p1v, p2u, p2v, p3u, p3v, p4u, p4v) {
            let vertexCoord = [p1u, p1v, p2u, p2v, p4u, p4v,  //Pierwszy trójkąt
                p1u, p1v, p4u, p4v, p3u, p3v]; //Drugi trójkąt

            return vertexCoord;
        }

        function createRectColor(r, g, b) {
            let vertexColor = [r, g, b, r, g, b, r, g, b,  //Pierwszy trójkąt
                r, g, b, r, g, b, r, g, b]; //Drugi trójkąt

            return vertexColor;
        }
        function createNormal(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z) //Wyznaczenie wektora normalnego dla trójkąta
        {
            let v1x = p2x - p1x;
            let v1y = p2y - p1y;
            let v1z = p2z - p1z;

            let v2x = p3x - p1x;
            let v2y = p3y - p1y;
            let v2z = p3z - p1z;

            let v3x = v1y * v2z - v1z * v2y;
            let v3y = v1z * v2x - v1x * v2z;
            let v3z = v1x * v2y - v1y * v2x;

            vl = Math.sqrt(v3x * v3x + v3y * v3y + v3z * v3z); //Obliczenie długości wektora

            v3x /= vl; //Normalizacja na zakreś -1 1
            v3y /= vl;
            v3z /= vl;

            let vertexNormal = [v3x, v3y, v3z, v3x, v3y, v3z, v3x, v3y, v3z];
            return vertexNormal;
        }

        function CreateShpere(x, y, z, radius, numStepsElevation, numStepsAngle) {
            //Opis sceny 3D, położenie punktów w przestrzeni 3D w formacie X,Y,Z 
            let vertexPosition = []; //3 punkty po 3 składowe - X1,Y1,Z1, X2,Y2,Z2, X3,Y3,Z3 - 1 trójkąt
            let vertexNormal = [];
            let vertexColor = []; //3 punkty po 3 składowe - R1,G1,B1, R2,G2,B2, R3,G3,B3 - 1 trójkąt
            let vertexCoords = []; //3 punkty po 2 składowe - U1,V1, U2,V2, U3,V3 - 1 trójkąt

            let stepElevation = 90 / numStepsElevation;
            let stepAngle = 360 / numStepsAngle;
            for (let elevation = -90; elevation < 90; elevation += stepElevation) {
                let radiusXZ = radius * Math.cos(elevation * Math.PI / 180);
                let radiusY = radius * Math.sin(elevation * Math.PI / 180);

                let radiusXZ2 = radius * Math.cos((elevation + stepElevation) * Math.PI / 180);
                let radiusY2 = radius * Math.sin((elevation + stepElevation) * Math.PI / 180);

                for (let angle = 0; angle < 360; angle += stepAngle) {

                    let px1 = radiusXZ * Math.cos(angle * Math.PI / 180);
                    let py1 = radiusY;
                    let pz1 = radiusXZ * Math.sin(angle * Math.PI / 180);

                    let px2 = radiusXZ * Math.cos((angle + stepAngle) * Math.PI / 180);
                    let py2 = radiusY;
                    let pz2 = radiusXZ * Math.sin((angle + stepAngle) * Math.PI / 180);

                    let px3 = radiusXZ2 * Math.cos(angle * Math.PI / 180);
                    let py3 = radiusY2;
                    let pz3 = radiusXZ2 * Math.sin(angle * Math.PI / 180);

                    let px4 = radiusXZ2 * Math.cos((angle + stepAngle) * Math.PI / 180);
                    let py4 = radiusY2;
                    let pz4 = radiusXZ2 * Math.sin((angle + stepAngle) * Math.PI / 180);

                    vertexPosition.push(...createRect2(px1 + x, py1 + y, pz1 + z, px2 + x, py2 + y, pz2 + z, px3 + x, py3 + y, pz3 + z, px4 + x, py4 + y, pz4 + z));

                    let p1 = Math.sqrt(px1 * px1 + py1 * py1 + pz1 * pz1)
                    let p2 = Math.sqrt(px2 * px2 + py2 * py2 + pz2 * pz2)
                    let p3 = Math.sqrt(px3 * px3 + py3 * py3 + pz3 * pz3)
                    let p4 = Math.sqrt(px4 * px4 + py4 * py4 + pz4 * pz4)

                    px1 /= p1
                    py1 /= p1
                    pz1 /= p1

                    px2 /= p2
                    py2 /= p2
                    pz2 /= p2

                    px3 /= p3
                    py3 /= p3
                    pz3 /= p3

                    px4 /= p4
                    py4 /= p4
                    pz4 /= p4

                    vertexNormal.push(...createRect2(px1, py1, pz1, px2, py2, pz2, px3, py3, pz3, px4, py4, pz4));

                    vertexColor.push(...createRectColor(1.0, 1.0, 1.0));

                    vertexCoords.push(...createRectCoords(angle / 360.0, (elevation + 90.0) / 180.0, (stepAngle) / 360.0, 0.0, 0.0, (stepElevation) / 180.0));
                }
            }

            return [vertexPosition, vertexColor, vertexCoords, vertexNormal];
        }
        function startGL() {
            //alert("StartGL");
            let canvas = document.getElementById("canvas3D"); //wyszukanie obiektu w strukturze strony 
            gl = canvas.getContext("experimental-webgl"); //pobranie kontekstu OpenGL'u z obiektu canvas
            gl.viewportWidth = canvas.width; //przypisanie wybranej przez nas rozdzielczości do systemu OpenGL
            gl.viewportHeight = canvas.height;

            //Kod shaderów
            const vertextShaderSource = ` //Znak akcentu z przycisku tyldy - na lewo od przycisku 1 na klawiaturze
    precision highp float;
    attribute vec3 aVertexPosition; 
    attribute vec3 aVertexColor;
    attribute vec3 aVertexNormal;
    attribute vec2 aVertexCoords;
    uniform mat4 uMMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uInvMMatrix;
    uniform mat4 uVMatrix;
    uniform mat4 uPMatrix;
    varying vec3 vPos;
    varying vec3 vColor;
    varying vec2 vTexUV;
    varying vec3 vNormal;
    uniform float uNormalMul;
    void main(void) {
      vPos = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
      gl_Position = uPMatrix * uVMatrix * vec4(vPos,1.0); //Dokonanie transformacji położenia punktów z przestrzeni 3D do przestrzeni obrazu (2D)
      vNormal = normalize(mat3(uInvMMatrix) * uNormalMul*aVertexNormal); //Obrot wektorow normalnych
      vColor = aVertexColor;
      vTexUV = aVertexCoords;
    }
  `;
            const fragmentShaderSource = `
    precision highp float;
    varying vec3 vPos;
    varying vec3 vColor;
    varying vec2 vTexUV;
    varying vec3 vNormal;
    uniform sampler2D uSampler;
    uniform vec3 uLightPosition;
    void main(void) {
       vec3 lightDirection = normalize(uLightPosition - vPos);
       float brightness = max(dot(vNormal,lightDirection), 0.0);
      //gl_FragColor = vec4(vColor,1.0); //Ustalenie stałego koloru wszystkich punktów sceny
      //gl_FragColor = texture2D(uSampler,vTexUV)*vec4(vColor,1.0); //Odczytanie punktu tekstury i przypisanie go jako koloru danego punktu renderowaniej figury
      //gl_FragColor = vec4((vNormal+vec3(1.0,1.0,1.0))/2.0,1.0); 
      gl_FragColor = clamp(texture2D(uSampler,vTexUV) * vec4(brightness,brightness,brightness,1.0),0.0,1.0);
      //gl_FragColor = clamp(vec4(1.0,1.0,0.0,1.0) * vec4(brightness,brightness,brightness,1.0),0.0,1.0);
    }
  `;
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //Stworzenie obiektu shadera 
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource); //Podpięcie źródła kodu shader
            gl.shaderSource(vertexShader, vertextShaderSource);
            gl.compileShader(fragmentShader); //Kompilacja kodu shader
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { //Sprawdzenie ewentualnych błedów kompilacji
                alert(gl.getShaderInfoLog(fragmentShader));
                return null;
            }
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(vertexShader));
                return null;
            }

            shaderProgram = gl.createProgram(); //Stworzenie obiektu programu 
            gl.attachShader(shaderProgram, vertexShader); //Podpięcie obu shaderów do naszego programu wykonywanego na karcie graficznej
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) alert("Could not initialise shaders");  //Sprawdzenie ewentualnych błedów

            //Opis sceny 3D, położenie punktów w przestrzeni 3D w formacie X,Y,Z 
            let vertexPosition; //3 punkty po 3 składowe - X1,Y1,Z1, X2,Y2,Z2, X3,Y3,Z3 - 1 trójkąt
            let vertexColor;
            let vertexCoords;
            let vertexNormal;

            [vertexPosition, vertexColor, vertexCoords, vertexNormal] = CreateShpere(0, 0, 0, 2, 6, 12);
            //[vertexPosition, vertexNormal] = CreateBox(0,0,0,1,1,1);

            vertexPositionBuffer = gl.createBuffer(); //Stworzenie tablicy w pamieci karty graficznej
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPosition), gl.STATIC_DRAW);
            vertexPositionBuffer.itemSize = 3; //zdefiniowanie liczby współrzednych per wierzchołek
            vertexPositionBuffer.numItems = vertexPosition.length / 9; //Zdefinoiowanie liczby trójkątów w naszym buforze

            vertexColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexColor), gl.STATIC_DRAW);
            vertexColorBuffer.itemSize = 3;
            vertexColorBuffer.numItems = vertexColor.length / 9;

            vertexCoordsBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexCoords), gl.STATIC_DRAW);
            vertexCoordsBuffer.itemSize = 2;
            vertexCoordsBuffer.numItems = vertexCoords.length / 6;

            vertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormal), gl.STATIC_DRAW);
            vertexNormalBuffer.itemSize = 3;
            vertexNormalBuffer.numItems = vertexNormal.length / 9;

            textureBuffer0 = gl.createTexture();
            var textureImg0 = new Image();
            textureImg0.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer0);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg0); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg0.src = "sun.jpg";
            textureBuffer1 = gl.createTexture();
            var textureImg1 = new Image();
            textureImg1.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer1);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg1); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg1.src = "mercury.jpg";
            textureBuffer2 = gl.createTexture();
            var textureImg2 = new Image();
            textureImg2.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer2);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg2); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg2.src = "venus.jpg";
            textureBuffer3 = gl.createTexture();
            var textureImg3 = new Image();
            textureImg3.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer3);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg3); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg3.src = "earth.jpg";
            textureBuffer4 = gl.createTexture();
            var textureImg4 = new Image();
            textureImg4.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer4);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg4); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg4.src = "mars.jpg";
            textureBuffer5 = gl.createTexture();
            var textureImg5 = new Image();
            textureImg5.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer5);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg5); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg5.src = "jupiter.jpg";
            textureBuffer6 = gl.createTexture();
            var textureImg6 = new Image();
            textureImg6.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer6);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg6); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg6.src = "saturn.jpg";
            textureBuffer7 = gl.createTexture();
            var textureImg7 = new Image();
            textureImg7.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer7);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg7); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg7.src = "uranus.jpg";
            textureBuffer8 = gl.createTexture();
            var textureImg8 = new Image();
            textureImg8.onload = function () { //Wykonanie kodu automatycznie po załadowaniu obrazka
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer8);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg8); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }

            textureImg8.src = "neptune.jpg";
            //Macierze opisujące położenie wirtualnej kamery w przestrzenie 3D
            let aspect = gl.viewportWidth / gl.viewportHeight;
            let fov = 45.0 * Math.PI / 180.0; //Określenie pola widzenia kamery
            let zFar = 100.0; //Ustalenie zakresów renderowania sceny 3D (od obiektu najbliższego zNear do najdalszego zFar)
            let zNear = 0.1;
            uPMatrix = [
                1.0 / (aspect * Math.tan(fov / 2)), 0, 0, 0,
                0, 1.0 / (Math.tan(fov / 2)), 0, 0,
                0, 0, -(zFar + zNear) / (zFar - zNear), -1,
                0, 0, -(2 * zFar * zNear) / (zFar - zNear), 0.0,
            ];
            Tick();
        }
        //let angle = 45.0; //Macierz transformacji świata - określenie położenia kamery 

        var angleZ = 0.0;
        var angleY = 0.0;
        var angleX = 0.0;
        var ty = 0.0;
        var tx = 0.0;

        var angle0 = 0.0;
        var angle1 = 0.0;
        var angle2 = 0.0;
        var angle3 = 0.0;
        var angle4 = 0.0;
        var angle5 = 0.0;
        var angle6 = 0.0;
        var angle7 = 0.0;
        var angle8 = 0.0;

        var radius0 = 0.0;
        var radius1 = 4.0;
        var radius2 = 6.0;
        var radius3 = 10.0;
        var radius4 = 12.0;
        var radius5 = 14.0;
        var radius6 = 19.0;
        var radius7 = 22.0;
        var radius8 = 26.0;

        var KameraPositionZ = -32.0;



        var Object0PositionX = 0.0;
        var Object0PositionY = 0.0;
        var Object0PositionZ = 0.0;


        var Object1PositionX = 3.0;
        var Object1PositionY = 0.0;
        var Object1PositionZ = 0.0;


        var Object2PositionX = 11.0;
        var Object2PositionY = 0.0;
        var Object2PositionZ = 0.0;


        var Object3PositionX = 14.0;
        var Object3PositionY = 0.0;
        var Object3PositionZ = 0.0;


        var Object4PositionX = 16.0;
        var Object4PositionY = 0.0;
        var Object4PositionZ = 0.0;


        var Object5PositionX = 21.0;
        var Object5PositionY = 0.0;
        var Object5PositionZ = 0.0;


        var Object6PositionX = 27.0;
        var Object6PositionY = 0.0;
        var Object6PositionZ = 0.0;


        var Object7PositionX = 31.0;
        var Object7PositionY = 0.0;
        var Object7PositionZ = 0.0;


        var Object8PositionX = 36.0;
        var Object8PositionY = 0.0;
        var Object8PositionZ = 0.0;


        var LightSize = 1;

        var Object0Size = 1.75;
        var Object1Size = 0.10;
        var Object2Size = 0.18;
        var Object3Size = 0.15;
        var Object4Size = 0.12;
        var Object5Size = 0.45;
        var Object6Size = 0.40;
        var Object7Size = 0.33;
        var Object8Size = 0.32;

        var LightPositionX = 0;
        var LightPositionY = 0;
        var LightPositionZ = -30.0;


        function Tick() {
            let uMMatrix0 = CreateIdentytyMatrix();
            let uMMatrix1 = CreateIdentytyMatrix();
            let uMMatrix2 = CreateIdentytyMatrix();
            let uMMatrix3 = CreateIdentytyMatrix();
            let uMMatrix4 = CreateIdentytyMatrix();
            let uMMatrix5 = CreateIdentytyMatrix();
            let uMMatrix6 = CreateIdentytyMatrix();
            let uMMatrix7 = CreateIdentytyMatrix();
            let uMMatrix8 = CreateIdentytyMatrix();

            let uVMatrix = CreateIdentytyMatrix();

            angle0 += 1;
            angle1 += 3;
            angle2 += 1;
            angle3 += 0.7;
            angle4 += 0.4;
            angle5 += 0.3;
            angle6 += 0.2;
            angle7 += 0.15;
            angle8 += 0.1;

            Object0PositionX = radius0 * Math.cos((angle0) * Math.PI / 180);
            Object0PositionZ = radius0 * Math.sin((angle0) * Math.PI / 180);

            Object1PositionX = radius1 * Math.cos((angle1) * Math.PI / 180);
            Object1PositionZ = radius1 * Math.sin((angle1) * Math.PI / 180);

            Object2PositionX = radius2 * Math.cos((angle2) * Math.PI / 180);
            Object2PositionZ = radius2 * Math.sin((angle2) * Math.PI / 180);

            Object3PositionX = radius3 * Math.cos((angle3) * Math.PI / 180);
            Object3PositionZ = radius3 * Math.sin((angle3) * Math.PI / 180);

            Object4PositionX = radius4 * Math.cos((angle4) * Math.PI / 180);
            Object4PositionZ = radius4 * Math.sin((angle4) * Math.PI / 180);

            Object5PositionX = radius5 * Math.cos((angle5) * Math.PI / 180);
            Object5PositionZ = radius5 * Math.sin((angle5) * Math.PI / 180);

            Object6PositionX = radius6 * Math.cos((angle6) * Math.PI / 180);
            Object6PositionZ = radius6 * Math.sin((angle6) * Math.PI / 180);

            Object7PositionX = radius7 * Math.cos((angle7) * Math.PI / 180);
            Object7PositionZ = radius7 * Math.sin((angle7) * Math.PI / 180);

            Object8PositionX = radius8 * Math.cos((angle8) * Math.PI / 180);
            Object8PositionZ = radius8 * Math.sin((angle8) * Math.PI / 180);

            uVMatrix = MatrixMul(uVMatrix, CreateRotationXMatrix(angleX));
            uVMatrix = MatrixMul(uVMatrix, CreateRotationYMatrix(angleY));
            uVMatrix = MatrixMul(uVMatrix, CreateRotationZMatrix(angleZ));
            uVMatrix = MatrixMul(uVMatrix, CreateTranslationMatrix(angleX, angleY, KameraPositionZ));

            uMMatrix0 = MatrixMul(uMMatrix0, CreateScaleMatrix(Object0Size, Object0Size, Object0Size));
            uMMatrix0 = MatrixMul(uMMatrix0, CreateTranslationMatrix(Object0PositionX, Object0PositionY, Object0PositionZ));
            uMMatrix0 = MatrixMul(uMMatrix0, CreateRotationXMatrix(angleX));
            uMMatrix0 = MatrixMul(uMMatrix0, CreateRotationYMatrix(angleY));
            uMMatrix0 = MatrixMul(uMMatrix0, CreateRotationZMatrix(angleZ));
            uMMatrix0 = MatrixMul(uMMatrix0, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix1 = MatrixMul(uMMatrix1, CreateScaleMatrix(Object1Size, Object1Size, Object1Size));
            uMMatrix1 = MatrixMul(uMMatrix1, CreateTranslationMatrix(Object1PositionX, Object1PositionY, Object1PositionZ));
            uMMatrix1 = MatrixMul(uMMatrix1, CreateRotationXMatrix(angleX));
            uMMatrix1 = MatrixMul(uMMatrix1, CreateRotationYMatrix(angleY));
            uMMatrix1 = MatrixMul(uMMatrix1, CreateRotationZMatrix(angleZ));
            uMMatrix1 = MatrixMul(uMMatrix1, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix2 = MatrixMul(uMMatrix2, CreateScaleMatrix(Object2Size, Object2Size, Object2Size));
            uMMatrix2 = MatrixMul(uMMatrix2, CreateTranslationMatrix(Object2PositionX, Object2PositionY, Object2PositionZ));
            uMMatrix2 = MatrixMul(uMMatrix2, CreateRotationXMatrix(angleX));
            uMMatrix2 = MatrixMul(uMMatrix2, CreateRotationYMatrix(angleY));
            uMMatrix2 = MatrixMul(uMMatrix2, CreateRotationZMatrix(angleZ));
            uMMatrix2 = MatrixMul(uMMatrix2, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix3 = MatrixMul(uMMatrix3, CreateScaleMatrix(Object3Size, Object3Size, Object3Size));
            uMMatrix3 = MatrixMul(uMMatrix3, CreateTranslationMatrix(Object3PositionX, Object3PositionY, Object3PositionZ));
            uMMatrix3 = MatrixMul(uMMatrix3, CreateRotationXMatrix(angleX));
            uMMatrix3 = MatrixMul(uMMatrix3, CreateRotationYMatrix(angleY));
            uMMatrix3 = MatrixMul(uMMatrix3, CreateRotationZMatrix(angleZ));
            uMMatrix3 = MatrixMul(uMMatrix3, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix4 = MatrixMul(uMMatrix4, CreateScaleMatrix(Object4Size, Object4Size, Object4Size));
            uMMatrix4 = MatrixMul(uMMatrix4, CreateTranslationMatrix(Object4PositionX, Object4PositionY, Object4PositionZ));
            uMMatrix4 = MatrixMul(uMMatrix4, CreateRotationXMatrix(angleX));
            uMMatrix4 = MatrixMul(uMMatrix4, CreateRotationYMatrix(angleY));
            uMMatrix4 = MatrixMul(uMMatrix4, CreateRotationZMatrix(angleZ));
            uMMatrix4 = MatrixMul(uMMatrix4, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix5 = MatrixMul(uMMatrix5, CreateScaleMatrix(Object5Size, Object5Size, Object5Size));
            uMMatrix5 = MatrixMul(uMMatrix5, CreateTranslationMatrix(Object5PositionX, Object5PositionY, Object5PositionZ));
            uMMatrix5 = MatrixMul(uMMatrix5, CreateRotationXMatrix(angleX));
            uMMatrix5 = MatrixMul(uMMatrix5, CreateRotationYMatrix(angleY));
            uMMatrix5 = MatrixMul(uMMatrix5, CreateRotationZMatrix(angleZ));
            uMMatrix5 = MatrixMul(uMMatrix5, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix6 = MatrixMul(uMMatrix6, CreateScaleMatrix(Object6Size, Object6Size, Object6Size));
            uMMatrix6 = MatrixMul(uMMatrix6, CreateTranslationMatrix(Object6PositionX, Object6PositionY, Object6PositionZ));
            uMMatrix6 = MatrixMul(uMMatrix6, CreateRotationXMatrix(angleX));
            uMMatrix6 = MatrixMul(uMMatrix6, CreateRotationYMatrix(angleY));
            uMMatrix6 = MatrixMul(uMMatrix6, CreateRotationZMatrix(angleZ));
            uMMatrix6 = MatrixMul(uMMatrix6, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix7 = MatrixMul(uMMatrix7, CreateScaleMatrix(Object7Size, Object7Size, Object7Size));
            uMMatrix7 = MatrixMul(uMMatrix7, CreateTranslationMatrix(Object7PositionX, Object7PositionY, Object7PositionZ));
            uMMatrix7 = MatrixMul(uMMatrix7, CreateRotationXMatrix(angleX));
            uMMatrix7 = MatrixMul(uMMatrix7, CreateRotationYMatrix(angleY));
            uMMatrix7 = MatrixMul(uMMatrix7, CreateRotationZMatrix(angleZ));
            uMMatrix7 = MatrixMul(uMMatrix7, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            uMMatrix8 = MatrixMul(uMMatrix8, CreateScaleMatrix(Object8Size, Object8Size, Object8Size));
            uMMatrix8 = MatrixMul(uMMatrix8, CreateTranslationMatrix(Object8PositionX, Object8PositionY, Object8PositionZ));
            uMMatrix8 = MatrixMul(uMMatrix8, CreateRotationXMatrix(angleX));
            uMMatrix8 = MatrixMul(uMMatrix8, CreateRotationYMatrix(angleY));
            uMMatrix8 = MatrixMul(uMMatrix8, CreateRotationZMatrix(angleZ));
            uMMatrix8 = MatrixMul(uMMatrix8, CreateTranslationMatrix(tx, ty, KameraPositionZ));

            //alert(uPMatrix);


            //Render Scene
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clearColor(0.0, 0.0, 0.1, 1.0); //Wyczyszczenie obrazu kolorem czerwonym
            gl.clearDepth(1.0);             //Wyczyścienie bufora głebi najdalszym planem
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.useProgram(shaderProgram)   //Użycie przygotowanego programu shaderowego

            gl.enable(gl.DEPTH_TEST);           // Włączenie testu głębi - obiekty bliższe mają przykrywać obiekty dalsze
            gl.depthFunc(gl.LEQUAL);            // 

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, new Float32Array(uPMatrix)); //Wgranie macierzy kamery do pamięci karty graficznej
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uVMatrix"), false, new Float32Array(uVMatrix));
            gl.uniform1f(gl.getUniformLocation(shaderProgram, "uNormalMul"), 1.0);


            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix1));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer1);
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix1)));


            gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));  //Przekazanie położenia
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexNormal"));  //Przekazywanie wektorów normalnych
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexNormal"), vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.uniform3f(gl.getUniformLocation(shaderProgram, "uLightPosition"), LightPositionX, LightPositionY, LightPositionZ);

            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix2));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix2)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer2);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix3));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix3)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer3);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix4));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix4)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer4);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix5));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix5)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer5);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix6));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix6)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer6);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix7));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix7)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer7);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix8));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix8)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer8);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix0));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uInvMMatrix"), false, new Float32Array(MatrixTransposeInverse(uMMatrix0)));
            gl.uniform1f(gl.getUniformLocation(shaderProgram, "uNormalMul"), -1.0);
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer0);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania

            setTimeout(Tick, 100);





        }
    </script>
</head>

<body onload="startGL()">
    <canvas id="canvas3D" width="640" height="480" style="border: solid black 1px"></canvas>
</body>

</html>